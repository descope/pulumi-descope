// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package descope

import (
	"context"
	"reflect"

	"errors"
	"github.com/descope/pulumi-descope/sdk/go/descope/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ManagementKey struct {
	pulumi.CustomResourceState

	// The plaintext value of the management key. This is only available after the key is created and cannot be retrieved later. Store this value securely as it is required to authenticate API requests.
	Cleartext pulumi.StringOutput `pulumi:"cleartext"`
	// A description for the management key.
	Description pulumi.StringOutput `pulumi:"description"`
	// The expiration time of the management key as a Unix timestamp. If not set, the key will not expire. Changing this value after creation will require the management key to be replaced.
	ExpireTime pulumi.IntOutput `pulumi:"expireTime"`
	// A name for the management key.
	Name pulumi.StringOutput `pulumi:"name"`
	// A list of IP addresses or CIDR ranges that are allowed to use this management key. If not set, the key can be used from any IP address.
	PermittedIps pulumi.StringArrayOutput `pulumi:"permittedIps"`
	// Access control settings for the management key. This defines the permissions granted to the management key, either at the company level or for specific projects or for project tags. Changing this value after creation will require the management key to be replaced.
	Rebac ManagementKeyRebacOutput `pulumi:"rebac"`
	// The status of the management key. Must be either `active` or `inactive`.
	Status pulumi.StringOutput `pulumi:"status"`
}

// NewManagementKey registers a new resource with the given unique name, arguments, and options.
func NewManagementKey(ctx *pulumi.Context,
	name string, args *ManagementKeyArgs, opts ...pulumi.ResourceOption) (*ManagementKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Rebac == nil {
		return nil, errors.New("invalid value for required argument 'Rebac'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"cleartext",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagementKey
	err := ctx.RegisterResource("descope:index/managementKey:ManagementKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagementKey gets an existing ManagementKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagementKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagementKeyState, opts ...pulumi.ResourceOption) (*ManagementKey, error) {
	var resource ManagementKey
	err := ctx.ReadResource("descope:index/managementKey:ManagementKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagementKey resources.
type managementKeyState struct {
	// The plaintext value of the management key. This is only available after the key is created and cannot be retrieved later. Store this value securely as it is required to authenticate API requests.
	Cleartext *string `pulumi:"cleartext"`
	// A description for the management key.
	Description *string `pulumi:"description"`
	// The expiration time of the management key as a Unix timestamp. If not set, the key will not expire. Changing this value after creation will require the management key to be replaced.
	ExpireTime *int `pulumi:"expireTime"`
	// A name for the management key.
	Name *string `pulumi:"name"`
	// A list of IP addresses or CIDR ranges that are allowed to use this management key. If not set, the key can be used from any IP address.
	PermittedIps []string `pulumi:"permittedIps"`
	// Access control settings for the management key. This defines the permissions granted to the management key, either at the company level or for specific projects or for project tags. Changing this value after creation will require the management key to be replaced.
	Rebac *ManagementKeyRebac `pulumi:"rebac"`
	// The status of the management key. Must be either `active` or `inactive`.
	Status *string `pulumi:"status"`
}

type ManagementKeyState struct {
	// The plaintext value of the management key. This is only available after the key is created and cannot be retrieved later. Store this value securely as it is required to authenticate API requests.
	Cleartext pulumi.StringPtrInput
	// A description for the management key.
	Description pulumi.StringPtrInput
	// The expiration time of the management key as a Unix timestamp. If not set, the key will not expire. Changing this value after creation will require the management key to be replaced.
	ExpireTime pulumi.IntPtrInput
	// A name for the management key.
	Name pulumi.StringPtrInput
	// A list of IP addresses or CIDR ranges that are allowed to use this management key. If not set, the key can be used from any IP address.
	PermittedIps pulumi.StringArrayInput
	// Access control settings for the management key. This defines the permissions granted to the management key, either at the company level or for specific projects or for project tags. Changing this value after creation will require the management key to be replaced.
	Rebac ManagementKeyRebacPtrInput
	// The status of the management key. Must be either `active` or `inactive`.
	Status pulumi.StringPtrInput
}

func (ManagementKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*managementKeyState)(nil)).Elem()
}

type managementKeyArgs struct {
	// A description for the management key.
	Description *string `pulumi:"description"`
	// The expiration time of the management key as a Unix timestamp. If not set, the key will not expire. Changing this value after creation will require the management key to be replaced.
	ExpireTime *int `pulumi:"expireTime"`
	// A name for the management key.
	Name *string `pulumi:"name"`
	// A list of IP addresses or CIDR ranges that are allowed to use this management key. If not set, the key can be used from any IP address.
	PermittedIps []string `pulumi:"permittedIps"`
	// Access control settings for the management key. This defines the permissions granted to the management key, either at the company level or for specific projects or for project tags. Changing this value after creation will require the management key to be replaced.
	Rebac ManagementKeyRebac `pulumi:"rebac"`
	// The status of the management key. Must be either `active` or `inactive`.
	Status *string `pulumi:"status"`
}

// The set of arguments for constructing a ManagementKey resource.
type ManagementKeyArgs struct {
	// A description for the management key.
	Description pulumi.StringPtrInput
	// The expiration time of the management key as a Unix timestamp. If not set, the key will not expire. Changing this value after creation will require the management key to be replaced.
	ExpireTime pulumi.IntPtrInput
	// A name for the management key.
	Name pulumi.StringPtrInput
	// A list of IP addresses or CIDR ranges that are allowed to use this management key. If not set, the key can be used from any IP address.
	PermittedIps pulumi.StringArrayInput
	// Access control settings for the management key. This defines the permissions granted to the management key, either at the company level or for specific projects or for project tags. Changing this value after creation will require the management key to be replaced.
	Rebac ManagementKeyRebacInput
	// The status of the management key. Must be either `active` or `inactive`.
	Status pulumi.StringPtrInput
}

func (ManagementKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managementKeyArgs)(nil)).Elem()
}

type ManagementKeyInput interface {
	pulumi.Input

	ToManagementKeyOutput() ManagementKeyOutput
	ToManagementKeyOutputWithContext(ctx context.Context) ManagementKeyOutput
}

func (*ManagementKey) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagementKey)(nil)).Elem()
}

func (i *ManagementKey) ToManagementKeyOutput() ManagementKeyOutput {
	return i.ToManagementKeyOutputWithContext(context.Background())
}

func (i *ManagementKey) ToManagementKeyOutputWithContext(ctx context.Context) ManagementKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementKeyOutput)
}

// ManagementKeyArrayInput is an input type that accepts ManagementKeyArray and ManagementKeyArrayOutput values.
// You can construct a concrete instance of `ManagementKeyArrayInput` via:
//
//	ManagementKeyArray{ ManagementKeyArgs{...} }
type ManagementKeyArrayInput interface {
	pulumi.Input

	ToManagementKeyArrayOutput() ManagementKeyArrayOutput
	ToManagementKeyArrayOutputWithContext(context.Context) ManagementKeyArrayOutput
}

type ManagementKeyArray []ManagementKeyInput

func (ManagementKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagementKey)(nil)).Elem()
}

func (i ManagementKeyArray) ToManagementKeyArrayOutput() ManagementKeyArrayOutput {
	return i.ToManagementKeyArrayOutputWithContext(context.Background())
}

func (i ManagementKeyArray) ToManagementKeyArrayOutputWithContext(ctx context.Context) ManagementKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementKeyArrayOutput)
}

// ManagementKeyMapInput is an input type that accepts ManagementKeyMap and ManagementKeyMapOutput values.
// You can construct a concrete instance of `ManagementKeyMapInput` via:
//
//	ManagementKeyMap{ "key": ManagementKeyArgs{...} }
type ManagementKeyMapInput interface {
	pulumi.Input

	ToManagementKeyMapOutput() ManagementKeyMapOutput
	ToManagementKeyMapOutputWithContext(context.Context) ManagementKeyMapOutput
}

type ManagementKeyMap map[string]ManagementKeyInput

func (ManagementKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagementKey)(nil)).Elem()
}

func (i ManagementKeyMap) ToManagementKeyMapOutput() ManagementKeyMapOutput {
	return i.ToManagementKeyMapOutputWithContext(context.Background())
}

func (i ManagementKeyMap) ToManagementKeyMapOutputWithContext(ctx context.Context) ManagementKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementKeyMapOutput)
}

type ManagementKeyOutput struct{ *pulumi.OutputState }

func (ManagementKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagementKey)(nil)).Elem()
}

func (o ManagementKeyOutput) ToManagementKeyOutput() ManagementKeyOutput {
	return o
}

func (o ManagementKeyOutput) ToManagementKeyOutputWithContext(ctx context.Context) ManagementKeyOutput {
	return o
}

// The plaintext value of the management key. This is only available after the key is created and cannot be retrieved later. Store this value securely as it is required to authenticate API requests.
func (o ManagementKeyOutput) Cleartext() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagementKey) pulumi.StringOutput { return v.Cleartext }).(pulumi.StringOutput)
}

// A description for the management key.
func (o ManagementKeyOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagementKey) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// The expiration time of the management key as a Unix timestamp. If not set, the key will not expire. Changing this value after creation will require the management key to be replaced.
func (o ManagementKeyOutput) ExpireTime() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagementKey) pulumi.IntOutput { return v.ExpireTime }).(pulumi.IntOutput)
}

// A name for the management key.
func (o ManagementKeyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagementKey) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A list of IP addresses or CIDR ranges that are allowed to use this management key. If not set, the key can be used from any IP address.
func (o ManagementKeyOutput) PermittedIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ManagementKey) pulumi.StringArrayOutput { return v.PermittedIps }).(pulumi.StringArrayOutput)
}

// Access control settings for the management key. This defines the permissions granted to the management key, either at the company level or for specific projects or for project tags. Changing this value after creation will require the management key to be replaced.
func (o ManagementKeyOutput) Rebac() ManagementKeyRebacOutput {
	return o.ApplyT(func(v *ManagementKey) ManagementKeyRebacOutput { return v.Rebac }).(ManagementKeyRebacOutput)
}

// The status of the management key. Must be either `active` or `inactive`.
func (o ManagementKeyOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagementKey) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

type ManagementKeyArrayOutput struct{ *pulumi.OutputState }

func (ManagementKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagementKey)(nil)).Elem()
}

func (o ManagementKeyArrayOutput) ToManagementKeyArrayOutput() ManagementKeyArrayOutput {
	return o
}

func (o ManagementKeyArrayOutput) ToManagementKeyArrayOutputWithContext(ctx context.Context) ManagementKeyArrayOutput {
	return o
}

func (o ManagementKeyArrayOutput) Index(i pulumi.IntInput) ManagementKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagementKey {
		return vs[0].([]*ManagementKey)[vs[1].(int)]
	}).(ManagementKeyOutput)
}

type ManagementKeyMapOutput struct{ *pulumi.OutputState }

func (ManagementKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagementKey)(nil)).Elem()
}

func (o ManagementKeyMapOutput) ToManagementKeyMapOutput() ManagementKeyMapOutput {
	return o
}

func (o ManagementKeyMapOutput) ToManagementKeyMapOutputWithContext(ctx context.Context) ManagementKeyMapOutput {
	return o
}

func (o ManagementKeyMapOutput) MapIndex(k pulumi.StringInput) ManagementKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagementKey {
		return vs[0].(map[string]*ManagementKey)[vs[1].(string)]
	}).(ManagementKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagementKeyInput)(nil)).Elem(), &ManagementKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagementKeyArrayInput)(nil)).Elem(), ManagementKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagementKeyMapInput)(nil)).Elem(), ManagementKeyMap{})
	pulumi.RegisterOutputType(ManagementKeyOutput{})
	pulumi.RegisterOutputType(ManagementKeyArrayOutput{})
	pulumi.RegisterOutputType(ManagementKeyMapOutput{})
}
