// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ProjectApplications {
    /**
     * Applications using OpenID Connect (OIDC) for authentication.
     */
    oidcApplications: outputs.ProjectApplicationsOidcApplication[];
    /**
     * Applications using SAML for authentication.
     */
    samlApplications: outputs.ProjectApplicationsSamlApplication[];
}

export interface ProjectApplicationsOidcApplication {
    /**
     * A list of supported claims. e.g. `sub`, `email`, `exp`.
     */
    claims: string[];
    /**
     * A description for the OIDC application.
     */
    description: string;
    /**
     * Whether the application should be enabled or disabled.
     */
    disabled: boolean;
    /**
     * This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
     */
    forceAuthentication: boolean;
    /**
     * An optional identifier for the OIDC application.
     */
    id: string;
    /**
     * The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
     */
    loginPageUrl: string;
    /**
     * A logo for the OIDC application. Should be a hosted image URL.
     */
    logo: string;
    /**
     * A name for the OIDC application.
     */
    name: string;
}

export interface ProjectApplicationsSamlApplication {
    /**
     * A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
     */
    acsAllowedCallbackUrls: string[];
    /**
     * The `AttributeMapping` object. Read the description below.
     */
    attributeMappings: outputs.ProjectApplicationsSamlApplicationAttributeMapping[];
    /**
     * The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
     */
    defaultRelayState: string;
    /**
     * A description for the SAML application.
     */
    description: string;
    /**
     * Whether the application should be enabled or disabled.
     */
    disabled: boolean;
    /**
     * The `DynamicConfiguration` object. Read the description below.
     */
    dynamicConfiguration: outputs.ProjectApplicationsSamlApplicationDynamicConfiguration;
    /**
     * This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
     */
    forceAuthentication: boolean;
    /**
     * An optional identifier for the SAML application.
     */
    id: string;
    /**
     * The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
     */
    loginPageUrl: string;
    /**
     * A logo for the SAML application. Should be a hosted image URL.
     */
    logo: string;
    /**
     * The `ManualConfiguration` object. Read the description below.
     */
    manualConfiguration: outputs.ProjectApplicationsSamlApplicationManualConfiguration;
    /**
     * A name for the SAML application.
     */
    name: string;
    /**
     * The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
     */
    subjectNameIdFormat: string;
    /**
     * The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
     */
    subjectNameIdType: string;
}

export interface ProjectApplicationsSamlApplicationAttributeMapping {
    /**
     * The name of the attribute.
     */
    name: string;
    /**
     * The value of the attribute.
     */
    value: string;
}

export interface ProjectApplicationsSamlApplicationDynamicConfiguration {
    /**
     * The metadata URL when retrieving the connection details dynamically.
     */
    metadataUrl: string;
}

export interface ProjectApplicationsSamlApplicationManualConfiguration {
    /**
     * Enter the `ACS URL` from the SP.
     */
    acsUrl: string;
    /**
     * Enter the `Certificate` from the SP.
     */
    certificate: string;
    /**
     * Enter the `Entity Id` from the SP.
     */
    entityId: string;
}

export interface ProjectAttributes {
    /**
     * A list of `TenantAttribute`. Read the description below.
     */
    tenants: outputs.ProjectAttributesTenant[];
    /**
     * A list of `UserAttribute`. Read the description below.
     */
    users: outputs.ProjectAttributesUser[];
}

export interface ProjectAttributesTenant {
    /**
     * Determines the required permissions for this tenant.
     */
    authorization: outputs.ProjectAttributesTenantAuthorization;
    /**
     * An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
     */
    id: string;
    /**
     * The name of the attribute. This value is called `Display Name` in the Descope console.
     */
    name: string;
    /**
     * When the attribute type is "multiselect". A list of options to choose from.
     */
    selectOptions: string[];
    /**
     * The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
     */
    type: string;
}

export interface ProjectAttributesTenantAuthorization {
    /**
     * Determines the required permissions for this tenant.
     */
    viewPermissions: string[];
}

export interface ProjectAttributesUser {
    /**
     * An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
     */
    id: string;
    /**
     * The name of the attribute. This value is called `Display Name` in the Descope console.
     */
    name: string;
    /**
     * When the attribute type is "multiselect". A list of options to choose from.
     */
    selectOptions: string[];
    /**
     * The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
     */
    type: string;
    /**
     * Determines the permissions users are required to have to access this attribute in the user management widget.
     */
    widgetAuthorization: outputs.ProjectAttributesUserWidgetAuthorization;
}

export interface ProjectAttributesUserWidgetAuthorization {
    /**
     * The permissions users are required to have to edit this attribute in the user management widget.
     */
    editPermissions: string[];
    /**
     * The permissions users are required to have to view this attribute in the user management widget.
     */
    viewPermissions: string[];
}

export interface ProjectAuthentication {
    /**
     * Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
     */
    embeddedLink: outputs.ProjectAuthenticationEmbeddedLink;
    /**
     * An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
     */
    enchantedLink: outputs.ProjectAuthenticationEnchantedLink;
    /**
     * An authentication method where a user receives a unique link via email to log in.
     */
    magicLink: outputs.ProjectAuthenticationMagicLink;
    /**
     * Authentication using Open Authorization, which allows users to authenticate with various external services.
     */
    oauth: outputs.ProjectAuthenticationOauth;
    /**
     * A dynamically generated set of numbers, granting the user one-time access.
     */
    otp: outputs.ProjectAuthenticationOtp;
    /**
     * Device-based passwordless authentication, using fingerprint, face scan, and more.
     */
    passkeys: outputs.ProjectAuthenticationPasskeys;
    /**
     * The classic username and password combination used for authentication.
     */
    password: outputs.ProjectAuthenticationPassword;
    /**
     * Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
     */
    sso: outputs.ProjectAuthenticationSso;
    /**
     * A one-time code generated for the user using a shared secret and time.
     */
    totp: outputs.ProjectAuthenticationTotp;
}

export interface ProjectAuthenticationEmbeddedLink {
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * How long the embedded link remains valid before it expires.
     */
    expirationTime: string;
}

export interface ProjectAuthenticationEnchantedLink {
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * Settings related to sending emails as part of the enchanted link authentication.
     */
    emailService: outputs.ProjectAuthenticationEnchantedLinkEmailService;
    /**
     * How long the enchanted link remains valid before it expires.
     */
    expirationTime: string;
    /**
     * The URL to redirect users to after they log in using the enchanted link.
     */
    redirectUrl: string;
}

export interface ProjectAuthenticationEnchantedLinkEmailService {
    /**
     * The name of the email connector to use for sending emails.
     */
    connector: string;
    /**
     * A list of email templates for different authentication flows.
     */
    templates: outputs.ProjectAuthenticationEnchantedLinkEmailServiceTemplate[];
}

export interface ProjectAuthenticationEnchantedLinkEmailServiceTemplate {
    /**
     * Whether this email template is currently active and in use.
     */
    active: boolean;
    /**
     * HTML content of the email message body, required if `usePlainTextBody` isn't set.
     */
    htmlBody: string;
    id: string;
    /**
     * Unique name for this email template.
     */
    name: string;
    /**
     * Plain text version of the email message body, required if `usePlainTextBody` is set to `true`.
     */
    plainTextBody: string;
    /**
     * Subject line of the email message.
     */
    subject: string;
    /**
     * Whether to use the plain text body instead of HTML for the email.
     */
    usePlainTextBody: boolean;
}

export interface ProjectAuthenticationMagicLink {
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * Settings related to sending emails as part of the magic link authentication.
     */
    emailService: outputs.ProjectAuthenticationMagicLinkEmailService;
    /**
     * How long the magic link remains valid before it expires.
     */
    expirationTime: string;
    /**
     * The URL to redirect users to after they log in using the magic link.
     */
    redirectUrl: string;
    /**
     * Settings related to sending SMS messages as part of the magic link authentication.
     */
    textService: outputs.ProjectAuthenticationMagicLinkTextService;
}

export interface ProjectAuthenticationMagicLinkEmailService {
    /**
     * The name of the email connector to use for sending emails.
     */
    connector: string;
    /**
     * A list of email templates for different authentication flows.
     */
    templates: outputs.ProjectAuthenticationMagicLinkEmailServiceTemplate[];
}

export interface ProjectAuthenticationMagicLinkEmailServiceTemplate {
    /**
     * Whether this email template is currently active and in use.
     */
    active: boolean;
    /**
     * HTML content of the email message body, required if `usePlainTextBody` isn't set.
     */
    htmlBody: string;
    id: string;
    /**
     * Unique name for this email template.
     */
    name: string;
    /**
     * Plain text version of the email message body, required if `usePlainTextBody` is set to `true`.
     */
    plainTextBody: string;
    /**
     * Subject line of the email message.
     */
    subject: string;
    /**
     * Whether to use the plain text body instead of HTML for the email.
     */
    usePlainTextBody: boolean;
}

export interface ProjectAuthenticationMagicLinkTextService {
    /**
     * The name of the SMS/text connector to use for sending text messages.
     */
    connector: string;
    /**
     * A list of text message templates for different authentication flows.
     */
    templates: outputs.ProjectAuthenticationMagicLinkTextServiceTemplate[];
}

export interface ProjectAuthenticationMagicLinkTextServiceTemplate {
    /**
     * Whether this text template is currently active and in use.
     */
    active: boolean;
    /**
     * The content of the text message.
     */
    body: string;
    id: string;
    /**
     * Unique name for this text template.
     */
    name: string;
}

export interface ProjectAuthenticationOauth {
    /**
     * Custom OAuth providers configured for this project.
     */
    custom: {[key: string]: outputs.ProjectAuthenticationOauthCustom};
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
     */
    system: outputs.ProjectAuthenticationOauthSystem;
}

export interface ProjectAuthenticationOauthCustom {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthCustomAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthCustomNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthCustomProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthCustomAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthCustomNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthCustomProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystem {
    /**
     * Apple's OAuth provider, allowing users to authenticate with their Apple Account.
     */
    apple: outputs.ProjectAuthenticationOauthSystemApple;
    /**
     * Discord's OAuth provider, allowing users to authenticate with their Discord account.
     */
    discord: outputs.ProjectAuthenticationOauthSystemDiscord;
    /**
     * Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
     */
    facebook: outputs.ProjectAuthenticationOauthSystemFacebook;
    /**
     * GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
     */
    github: outputs.ProjectAuthenticationOauthSystemGithub;
    /**
     * GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
     */
    gitlab: outputs.ProjectAuthenticationOauthSystemGitlab;
    /**
     * Google's OAuth provider, allowing users to authenticate with their Google account.
     */
    google: outputs.ProjectAuthenticationOauthSystemGoogle;
    /**
     * LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
     */
    linkedin: outputs.ProjectAuthenticationOauthSystemLinkedin;
    /**
     * Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
     */
    microsoft: outputs.ProjectAuthenticationOauthSystemMicrosoft;
    /**
     * Slack's OAuth provider, allowing users to authenticate with their Slack account.
     */
    slack: outputs.ProjectAuthenticationOauthSystemSlack;
}

export interface ProjectAuthenticationOauthSystemApple {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemAppleAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemAppleNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemAppleProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemAppleAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemAppleNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemAppleProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemDiscord {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemDiscordAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemDiscordProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemDiscordAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemDiscordProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemFacebook {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemFacebookAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemFacebookProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemFacebookAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemFacebookProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemGithub {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemGithubAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemGithubNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemGithubProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemGithubAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemGithubNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemGithubProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemGitlab {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemGitlabAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemGitlabProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemGitlabAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemGitlabProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemGoogle {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemGoogleAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemGoogleProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemGoogleAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemGoogleProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemLinkedin {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemLinkedinAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemLinkedinProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemLinkedinAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemLinkedinProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemMicrosoft {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemMicrosoftAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemMicrosoftAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagement {
}

export interface ProjectAuthenticationOauthSystemSlack {
    /**
     * The type of grants (`authorizationCode` or `implicit`) to allow when requesting access tokens from the OAuth provider.
     */
    allowedGrantTypes: string[];
    /**
     * The apple key generator object describing how to create a dynamic apple client secret for applications.
     */
    appleKeyGenerator: outputs.ProjectAuthenticationOauthSystemSlackAppleKeyGenerator;
    /**
     * The URL that users are redirected to for authorization with the OAuth provider.
     */
    authorizationEndpoint: string;
    /**
     * Use a custom domain in your OAuth verification screen.
     */
    callbackDomain: string;
    /**
     * Maps OAuth provider claims to Descope user attributes.
     */
    claimMapping: {[key: string]: string};
    /**
     * The client ID for the OAuth provider, used to identify the application to the provider.
     */
    clientId: string;
    /**
     * The client secret for the OAuth provider, used to authenticate the application with the provider.
     */
    clientSecret: string;
    /**
     * A brief description of the OAuth provider.
     */
    description: string;
    /**
     * By default the user attribute mapping configuration is used to update the user's attributes automatically during sign in. Disable this if you want this to happen only during user creation.
     */
    disableJitUpdates: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The issuer identifier for the OAuth provider.
     */
    issuer: string;
    /**
     * The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
     */
    jwksEndpoint: string;
    /**
     * The URL of the logo associated with the OAuth provider.
     */
    logo: string;
    /**
     * Whether to enable provider token management for this OAuth provider.
     */
    manageProviderTokens: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through OAuth authentication.
     */
    mergeUserAccounts: boolean;
    /**
     * The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
     */
    nativeAppleKeyGenerator: outputs.ProjectAuthenticationOauthSystemSlackNativeAppleKeyGenerator;
    /**
     * The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientId: string;
    /**
     * The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
     */
    nativeClientSecret: string;
    /**
     * Custom prompts or consent screens that users may see during OAuth authentication.
     */
    prompts: string[];
    /**
     * This attribute is deprecated, use the `manageProviderTokens`, `callbackDomain`, and `redirectUrl` fields instead.
     */
    providerTokenManagement: outputs.ProjectAuthenticationOauthSystemSlackProviderTokenManagement;
    /**
     * Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
     */
    redirectUrl: string;
    /**
     * Scopes of access that the application requests from the user's account on the OAuth provider.
     */
    scopes: string[];
    /**
     * The URL where the application requests an access token from the OAuth provider.
     */
    tokenEndpoint: string;
    /**
     * Use private key JWT (client assertion) instead of client secret.
     */
    useClientAssertion: boolean;
    /**
     * The URL where the application retrieves user information from the OAuth provider.
     */
    userInfoEndpoint: string;
}

export interface ProjectAuthenticationOauthSystemSlackAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemSlackNativeAppleKeyGenerator {
    /**
     * The apple generator key id produced by Apple.
     */
    keyId: string;
    /**
     * The apple generator private key produced by Apple.
     */
    privateKey: string;
    /**
     * The apple generator team id assigned to the key by Apple.
     */
    teamId: string;
}

export interface ProjectAuthenticationOauthSystemSlackProviderTokenManagement {
}

export interface ProjectAuthenticationOtp {
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The domain to embed in OTP messages.
     */
    domain: string;
    /**
     * Settings related to sending emails with OTP codes.
     */
    emailService: outputs.ProjectAuthenticationOtpEmailService;
    /**
     * The amount of time that an OTP code will be valid for.
     */
    expirationTime: string;
    /**
     * Settings related to sending SMS messages with OTP codes.
     */
    textService: outputs.ProjectAuthenticationOtpTextService;
    /**
     * Settings related to voice calls with OTP codes.
     */
    voiceService: outputs.ProjectAuthenticationOtpVoiceService;
}

export interface ProjectAuthenticationOtpEmailService {
    /**
     * The name of the email connector to use for sending emails.
     */
    connector: string;
    /**
     * A list of email templates for different authentication flows.
     */
    templates: outputs.ProjectAuthenticationOtpEmailServiceTemplate[];
}

export interface ProjectAuthenticationOtpEmailServiceTemplate {
    /**
     * Whether this email template is currently active and in use.
     */
    active: boolean;
    /**
     * HTML content of the email message body, required if `usePlainTextBody` isn't set.
     */
    htmlBody: string;
    id: string;
    /**
     * Unique name for this email template.
     */
    name: string;
    /**
     * Plain text version of the email message body, required if `usePlainTextBody` is set to `true`.
     */
    plainTextBody: string;
    /**
     * Subject line of the email message.
     */
    subject: string;
    /**
     * Whether to use the plain text body instead of HTML for the email.
     */
    usePlainTextBody: boolean;
}

export interface ProjectAuthenticationOtpTextService {
    /**
     * The name of the SMS/text connector to use for sending text messages.
     */
    connector: string;
    /**
     * A list of text message templates for different authentication flows.
     */
    templates: outputs.ProjectAuthenticationOtpTextServiceTemplate[];
}

export interface ProjectAuthenticationOtpTextServiceTemplate {
    /**
     * Whether this text template is currently active and in use.
     */
    active: boolean;
    /**
     * The content of the text message.
     */
    body: string;
    id: string;
    /**
     * Unique name for this text template.
     */
    name: string;
}

export interface ProjectAuthenticationOtpVoiceService {
    /**
     * The name of the voice connector to use for making voice calls.
     */
    connector: string;
    /**
     * A list of voice message templates for different purposes.
     */
    templates: outputs.ProjectAuthenticationOtpVoiceServiceTemplate[];
}

export interface ProjectAuthenticationOtpVoiceServiceTemplate {
    /**
     * Whether this voice template is currently active and in use.
     */
    active: boolean;
    /**
     * The content of the voice message that will be spoken.
     */
    body: string;
    id: string;
    /**
     * Unique name for this voice template.
     */
    name: string;
}

export interface ProjectAuthenticationPasskeys {
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * Passkeys will be usable in the following domain and all its subdomains.
     */
    topLevelDomain: string;
}

export interface ProjectAuthenticationPassword {
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * Settings related to sending password reset emails as part of the password feature.
     */
    emailService: outputs.ProjectAuthenticationPasswordEmailService;
    /**
     * Whether users are required to change their password periodically.
     */
    expiration: boolean;
    /**
     * The number of weeks after which a user's password expires and they need to replace it.
     */
    expirationWeeks: number;
    /**
     * Whether the user account should be locked after a specified number of failed login attempts.
     */
    lock: boolean;
    /**
     * The number of failed login attempts allowed before an account is locked.
     */
    lockAttempts: number;
    /**
     * Whether passwords must contain at least one lowercase letter.
     */
    lowercase: boolean;
    /**
     * Prevents information about user accounts from being revealed in error messages, e.g., whether a user already exists.
     */
    maskErrors: boolean;
    /**
     * The minimum length of the password that users are required to use. The maximum length is always `64`.
     */
    minLength: number;
    /**
     * Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
     */
    nonAlphanumeric: boolean;
    /**
     * Whether passwords must contain at least one number.
     */
    number: boolean;
    /**
     * Whether to forbid password reuse when users change their password.
     */
    reuse: boolean;
    /**
     * The number of previous passwords whose hashes are kept to prevent users from reusing old passwords.
     */
    reuseAmount: number;
    /**
     * Whether the user account should be temporarily locked after a specified number of failed login attempts.
     */
    temporaryLock: boolean;
    /**
     * The number of failed login attempts allowed before an account is temporarily locked.
     */
    temporaryLockAttempts: number;
    /**
     * The amount of time before the user can sign in again after the account is temporarily locked.
     */
    temporaryLockDuration: string;
    /**
     * Whether passwords must contain at least one uppercase letter.
     */
    uppercase: boolean;
}

export interface ProjectAuthenticationPasswordEmailService {
    /**
     * The name of the email connector to use for sending emails.
     */
    connector: string;
    /**
     * A list of email templates for different authentication flows.
     */
    templates: outputs.ProjectAuthenticationPasswordEmailServiceTemplate[];
}

export interface ProjectAuthenticationPasswordEmailServiceTemplate {
    /**
     * Whether this email template is currently active and in use.
     */
    active: boolean;
    /**
     * HTML content of the email message body, required if `usePlainTextBody` isn't set.
     */
    htmlBody: string;
    id: string;
    /**
     * Unique name for this email template.
     */
    name: string;
    /**
     * Plain text version of the email message body, required if `usePlainTextBody` is set to `true`.
     */
    plainTextBody: string;
    /**
     * Subject line of the email message.
     */
    subject: string;
    /**
     * Whether to use the plain text body instead of HTML for the email.
     */
    usePlainTextBody: boolean;
}

export interface ProjectAuthenticationSso {
    /**
     * Whether to allow duplicate SSO domains across tenants.
     */
    allowDuplicateDomains: boolean;
    /**
     * Whether to allow overriding user's roles with SSO related roles.
     */
    allowOverrideRoles: boolean;
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * Whether to merge existing user accounts with new ones created through SSO authentication.
     */
    mergeUsers: boolean;
    /**
     * The URL the end user is redirected to after a successful authentication. If one is specified in tenant level settings or SDK/API call, they will override this value.
     */
    redirectUrl: string;
    /**
     * Configuration block for the SSO Suite.
     */
    ssoSuiteSettings: outputs.ProjectAuthenticationSsoSsoSuiteSettings;
}

export interface ProjectAuthenticationSsoSsoSuiteSettings {
    /**
     * Setting this to `true` will allow only verified domains to be used.
     */
    forceDomainVerification: boolean;
    /**
     * Setting this to `true` will hide the domains configuration section in the SSO Suite interface.
     */
    hideDomains: boolean;
    /**
     * Setting this to `true` will hide the groups mapping configuration section in the SSO Suite interface.
     */
    hideGroupsMapping: boolean;
    /**
     * Setting this to `true` will hide the OIDC configuration option.
     */
    hideOidc: boolean;
    /**
     * Setting this to `true` will hide the SAML configuration option.
     */
    hideSaml: boolean;
    /**
     * Setting this to `true` will hide the SCIM configuration in the SSO Suite interface.
     */
    hideScim: boolean;
    /**
     * Specifies the style ID to apply in the SSO Suite. Ensure a style with this ID exists in the console for it to be used.
     */
    styleId: string;
}

export interface ProjectAuthenticationTotp {
    /**
     * Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
     */
    disabled: boolean;
    /**
     * The template for the service issuer label (issuer) shown in the authenticator app.
     */
    serviceLabel: string;
}

export interface ProjectAuthorization {
    /**
     * A list of `Permission` objects.
     */
    permissions: outputs.ProjectAuthorizationPermission[];
    /**
     * A list of `Role` objects.
     */
    roles: outputs.ProjectAuthorizationRole[];
}

export interface ProjectAuthorizationPermission {
    /**
     * A description for the permission.
     */
    description: string;
    id: string;
    /**
     * A name for the permission.
     */
    name: string;
}

export interface ProjectAuthorizationRole {
    /**
     * Whether this role should automatically be assigned to users that are created without any roles.
     */
    default: boolean;
    /**
     * A description for the role.
     */
    description: string;
    id: string;
    key: string;
    /**
     * A name for the role.
     */
    name: string;
    /**
     * A list of permissions by name to be included in the role.
     */
    permissions: string[];
    /**
     * Whether this role should not be displayed to tenant admins.
     */
    private: boolean;
}

export interface ProjectConnectors {
    /**
     * Utilize IP threat intelligence to block malicious login attempts with the AbuseIPDB connector.
     */
    abuseipdbs: outputs.ProjectConnectorsAbuseipdb[];
    /**
     * Track user activity and traits at any point in your user journey with the Amplitude connector.
     */
    amplitudes: outputs.ProjectConnectorsAmplitude[];
    /**
     * Send audit events to a custom webhook.
     */
    auditWebhooks: outputs.ProjectConnectorsAuditWebhook[];
    /**
     * Stream authentication audit logs with the Amazon S3 connector.
     */
    awsS3s: outputs.ProjectConnectorsAwsS3[];
    /**
     * Localize the language of your login and user journey screens with the Amazon Translate connector.
     */
    awsTranslates: outputs.ProjectConnectorsAwsTranslate[];
    /**
     * Utilize threat intelligence to block malicious login attempts or check leaks with the Bitsight Threat Intelligence connector.
     */
    bitsights: outputs.ProjectConnectorsBitsight[];
    /**
     * Stream authentication audit logs with the Datadog connector.
     */
    datadogs: outputs.ProjectConnectorsDatadog[];
    /**
     * DevRev Grow is a Growth CRM that brings salespeople, product marketers, and PMs onto an AI-native platform to follow the journey of a visitor to a lead, to a contact, and then to a user - to create a champion, not a churned user.
     */
    devrevGrows: outputs.ProjectConnectorsDevrevGrow[];
    /**
     * Get user information from Docebo in your Descope user journeys with the Docebo connector.
     */
    docebos: outputs.ProjectConnectorsDocebo[];
    /**
     * Send Viber messages to the user.
     */
    eightByEightVibers: outputs.ProjectConnectorsEightByEightViber[];
    /**
     * Send WhatsApp messages to the user.
     */
    eightByEightWhatsapps: outputs.ProjectConnectorsEightByEightWhatsapp[];
    /**
     * Use this connector to obtain an identity trust score.
     */
    elephants: outputs.ProjectConnectorsElephant[];
    /**
     * A generic HTTP token connector.
     */
    externalTokenHttps: outputs.ProjectConnectorsExternalTokenHttp[];
    /**
     * Descope Fingerprint capabilities for fraud detection and risk assessment.
     */
    fingerprintDescopes: outputs.ProjectConnectorsFingerprintDescope[];
    /**
     * Prevent fraud by adding device intelligence with the Fingerprint connector.
     */
    fingerprints: outputs.ProjectConnectorsFingerprint[];
    /**
     * Firebase connector enables you to utilize Firebase's APIs to generate a Firebase user token for a given Descope user.
     */
    firebaseAdmins: outputs.ProjectConnectorsFirebaseAdmin[];
    /**
     * Leverage ML-based risk scores for fraud prevention with the Forter connector.
     */
    forters: outputs.ProjectConnectorsForter[];
    /**
     * Send emails using a generic Email gateway.
     */
    genericEmailGateways: outputs.ProjectConnectorsGenericEmailGateway[];
    /**
     * Send messages using a generic SMS gateway.
     */
    genericSmsGateways: outputs.ProjectConnectorsGenericSmsGateway[];
    /**
     * Stream logs and audit events with the Google Cloud Logging connector.
     */
    googleCloudLoggings: outputs.ProjectConnectorsGoogleCloudLogging[];
    /**
     * Localize the language of your login and user journey screens with the Google Cloud Translation connector.
     */
    googleCloudTranslations: outputs.ProjectConnectorsGoogleCloudTranslation[];
    /**
     * Get address autocompletions from Place Autocomplete Data API.
     */
    googleMapsPlaces: outputs.ProjectConnectorsGoogleMapsPlace[];
    /**
     * Check if passwords have been previously exposed in data breaches with the Have I Been Pwned connector.
     */
    hibps: outputs.ProjectConnectorsHibp[];
    /**
     * A general purpose HTTP client
     */
    https: outputs.ProjectConnectorsHttp[];
    /**
     * Orchestrate customer identity information from your Descope user journey with the HubSpot connector.
     */
    hubspots: outputs.ProjectConnectorsHubspot[];
    /**
     * Use the Incode connection to run identity verification processes like document checks or facial recognition.
     */
    incodes: outputs.ProjectConnectorsIncode[];
    /**
     * Orchestrate customer identity information from your Descope user journey with the Intercom connector.
     */
    intercoms: outputs.ProjectConnectorsIntercom[];
    /**
     * Localize the language of your login and user journey screens with the Lokalise connector.
     */
    lokalises: outputs.ProjectConnectorsLokalise[];
    /**
     * Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
     */
    mparticles: outputs.ProjectConnectorsMparticle[];
    /**
     * Stream authentication audit logs with the New Relic connector.
     */
    newrelics: outputs.ProjectConnectorsNewrelic[];
    /**
     * Get address autocompletions from Radar Autocomplete API.
     */
    radars: outputs.ProjectConnectorsRadar[];
    /**
     * Mitigate fraud using advanced risk analysis and add adaptive MFA with the reCAPTCHA Enterprise connector.
     */
    recaptchaEnterprises: outputs.ProjectConnectorsRecaptchaEnterprise[];
    /**
     * Prevent bot attacks on your login pages with the reCAPTCHA v3 connector.
     */
    recaptchas: outputs.ProjectConnectorsRecaptcha[];
    /**
     * Add image recognition capabilities for identity verification and fraud prevention with the Amazon Rekognition connector.
     */
    rekognitions: outputs.ProjectConnectorsRekognition[];
    /**
     * Send transactional messages with the Salesforce Marketing Cloud connector.
     */
    salesforceMarketingClouds: outputs.ProjectConnectorsSalesforceMarketingCloud[];
    /**
     * Run SQL queries to retrieve user roles, profiles, account status, and more with the Salesforce connector.
     */
    salesforces: outputs.ProjectConnectorsSalesforce[];
    /**
     * Evaluate customer risk using Sardine
     */
    sardines: outputs.ProjectConnectorsSardine[];
    /**
     * Orchestrate customer identity traits and signals from your Descope user journey with the Segment connector.
     */
    segments: outputs.ProjectConnectorsSegment[];
    /**
     * SendGrid is a cloud-based SMTP provider that allows you to send emails without having to maintain email servers.
     */
    sendgrids: outputs.ProjectConnectorsSendgrid[];
    /**
     * Amazon Simple Email Service (SES) for sending emails through AWS infrastructure.
     */
    ses: outputs.ProjectConnectorsSe[];
    /**
     * Send updates to your team on Slack.
     */
    slacks: outputs.ProjectConnectorsSlack[];
    /**
     * Localize the language of your login and user journey screens with the Smartling connector.
     */
    smartlings: outputs.ProjectConnectorsSmartling[];
    /**
     * Simple Mail Transfer Protocol (SMTP) server for sending emails.
     */
    smtps: outputs.ProjectConnectorsSmtp[];
    /**
     * Amazon Simple Notification Service (SNS) for sending SMS messages through AWS.
     */
    sns: outputs.ProjectConnectorsSn[];
    /**
     * Stream logs and audit events with the Sumo Logic connector.
     */
    sumologics: outputs.ProjectConnectorsSumologic[];
    /**
     * Generate external tokens for user authentication in Supabase projects.
     */
    supabases: outputs.ProjectConnectorsSupabase[];
    /**
     * Verify phone numbers and leverage granular risk scores for adaptive MFA with the Telesign Intelligence connector.
     */
    telesigns: outputs.ProjectConnectorsTelesign[];
    /**
     * Identify and respond to fraudulent login activity with the Traceable Digital Fraud Prevention connector.
     */
    traceables: outputs.ProjectConnectorsTraceable[];
    /**
     * Prevent bot attacks on your login pages with the Turnstile connector.
     */
    turnstiles: outputs.ProjectConnectorsTurnstile[];
    /**
     * Twilio is a cloud-based communication provider of communication tools for making and receiving phone calls, sending and receiving text messages, and performing other communication functions.
     */
    twilioCores: outputs.ProjectConnectorsTwilioCore[];
    /**
     * Twilio Verify is an OTP service that can be used via text messages, instant messaging platforms, voice and e-mail. Choose this connector only if you are a Twilio Verify customer.
     */
    twilioVerifies: outputs.ProjectConnectorsTwilioVerify[];
}

export interface ProjectConnectorsAbuseipdb {
    /**
     * The unique AbuseIPDB API key.
     */
    apiKey: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsAmplitude {
    /**
     * The Amplitude API Key generated for the Descope service.
     */
    apiKey: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
     */
    serverUrl: string;
    /**
     * `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
     */
    serverZone: string;
}

export interface ProjectConnectorsAuditWebhook {
    /**
     * Specify which events will be sent to the external audit service (including tenant selection).
     */
    auditFilters: outputs.ProjectConnectorsAuditWebhookAuditFilter[];
    /**
     * Authentication Information
     */
    authentication: outputs.ProjectConnectorsAuditWebhookAuthentication;
    /**
     * The base URL to fetch
     */
    baseUrl: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The headers to send with the request
     */
    headers: {[key: string]: string};
    /**
     * HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
     */
    hmacSecret: string;
    id: string;
    /**
     * Will ignore certificate errors raised by the client
     */
    insecure: boolean;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsAuditWebhookAuditFilter {
    /**
     * The field name to filter on (either 'actions' or 'tenants').
     */
    key: string;
    /**
     * The filter operation to apply ('includes' or 'excludes').
     */
    operator: string;
    /**
     * The list of values to match against for the filter.
     */
    values: string[];
}

export interface ProjectConnectorsAuditWebhookAuthentication {
    /**
     * API key authentication configuration.
     */
    apiKey: outputs.ProjectConnectorsAuditWebhookAuthenticationApiKey;
    /**
     * Basic authentication credentials (username and password).
     */
    basic: outputs.ProjectConnectorsAuditWebhookAuthenticationBasic;
    /**
     * Bearer token for HTTP authentication.
     */
    bearerToken: string;
}

export interface ProjectConnectorsAuditWebhookAuthenticationApiKey {
    /**
     * The API key.
     */
    key: string;
    /**
     * The API secret.
     */
    token: string;
}

export interface ProjectConnectorsAuditWebhookAuthenticationBasic {
    /**
     * Password for basic HTTP authentication.
     */
    password: string;
    /**
     * Username for basic HTTP authentication.
     */
    username: string;
}

export interface ProjectConnectorsAwsS3 {
    /**
     * The unique AWS access key ID.
     */
    accessKeyId: string;
    /**
     * Whether to enable streaming of audit events.
     */
    auditEnabled: boolean;
    /**
     * Specify which events will be sent to the external audit service (including tenant selection).
     */
    auditFilters: outputs.ProjectConnectorsAwsS3AuditFilter[];
    /**
     * The authentication type to use.
     */
    authType: string;
    /**
     * The AWS S3 bucket. This bucket should already exist for the connector to work.
     */
    bucket: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The external ID to use when assuming the role.
     */
    externalId: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The AWS S3 region, e.g. `us-east-1`.
     */
    region: string;
    /**
     * The Amazon Resource Name (ARN) of the role to assume.
     */
    roleArn: string;
    /**
     * The secret AWS access key.
     */
    secretAccessKey: string;
    /**
     * Whether to send troubleshooting events.
     */
    troubleshootLogEnabled: boolean;
}

export interface ProjectConnectorsAwsS3AuditFilter {
    /**
     * The field name to filter on (either 'actions' or 'tenants').
     */
    key: string;
    /**
     * The filter operation to apply ('includes' or 'excludes').
     */
    operator: string;
    /**
     * The list of values to match against for the filter.
     */
    values: string[];
}

export interface ProjectConnectorsAwsTranslate {
    /**
     * AWS access key ID.
     */
    accessKeyId: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The AWS region to which this client will send requests. (e.g. us-east-1.)
     */
    region: string;
    /**
     * AWS secret access key.
     */
    secretAccessKey: string;
    /**
     * (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
     */
    sessionToken: string;
}

export interface ProjectConnectorsBitsight {
    /**
     * API Client ID issued when you create the credentials in Bitsight Threat Intelligence.
     */
    clientId: string;
    /**
     * Client secret issued when you create the credentials in Bitsight Threat Intelligence.
     */
    clientSecret: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsDatadog {
    /**
     * The unique Datadog organization key.
     */
    apiKey: string;
    /**
     * Whether to enable streaming of audit events.
     */
    auditEnabled: boolean;
    /**
     * Specify which events will be sent to the external audit service (including tenant selection).
     */
    auditFilters: outputs.ProjectConnectorsDatadogAuditFilter[];
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * Whether to mask personally identifiable information in the logs.
     */
    maskPii: boolean;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
     */
    site: string;
    /**
     * Whether to send troubleshooting events.
     */
    troubleshootLogEnabled: boolean;
}

export interface ProjectConnectorsDatadogAuditFilter {
    /**
     * The field name to filter on (either 'actions' or 'tenants').
     */
    key: string;
    /**
     * The filter operation to apply ('includes' or 'excludes').
     */
    operator: string;
    /**
     * The list of values to match against for the filter.
     */
    values: string[];
}

export interface ProjectConnectorsDevrevGrow {
    /**
     * Authentication to DevRev APIs requires a personal access token (PAT).
     */
    apiKey: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsDocebo {
    /**
     * The Docebo api base url.
     */
    baseUrl: string;
    /**
     * The Docebo OAuth 2.0 app client ID.
     */
    clientId: string;
    /**
     * The Docebo OAuth 2.0 app client secret.
     */
    clientSecret: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Docebo user's password.
     */
    password: string;
    /**
     * The Docebo username.
     */
    username: string;
}

export interface ProjectConnectorsEightByEightViber {
    /**
     * The 8x8 API key for authentication.
     */
    apiKey: string;
    /**
     * The country code or region where your Viber messaging service is configured.
     */
    country: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The 8x8 sub-account ID is required for the Messaging API.
     */
    subAccountId: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsEightByEightWhatsapp {
    /**
     * The 8x8 API key for authentication.
     */
    apiKey: string;
    /**
     * The country code or region where your Viber messaging service is configured.
     */
    country: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The 8x8 sub-account ID is required for the Messaging API.
     */
    subAccountId: string;
    /**
     * The ID of a WhatsApp message template.
     */
    templateId: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsElephant {
    /**
     * The Elephant access key.
     */
    accessKey: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsExternalTokenHttp {
    /**
     * Authentication Information
     */
    authentication: outputs.ProjectConnectorsExternalTokenHttpAuthentication;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The endpoint to get the token from (Using POST method). Descope will send the user information in the body of the request, and should return a JSON response with a 'token' string field.
     */
    endpoint: string;
    /**
     * The headers to send with the request
     */
    headers: {[key: string]: string};
    /**
     * HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
     */
    hmacSecret: string;
    id: string;
    /**
     * Will ignore certificate errors raised by the client
     */
    insecure: boolean;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsExternalTokenHttpAuthentication {
    /**
     * API key authentication configuration.
     */
    apiKey: outputs.ProjectConnectorsExternalTokenHttpAuthenticationApiKey;
    /**
     * Basic authentication credentials (username and password).
     */
    basic: outputs.ProjectConnectorsExternalTokenHttpAuthenticationBasic;
    /**
     * Bearer token for HTTP authentication.
     */
    bearerToken: string;
}

export interface ProjectConnectorsExternalTokenHttpAuthenticationApiKey {
    /**
     * The API key.
     */
    key: string;
    /**
     * The API secret.
     */
    token: string;
}

export interface ProjectConnectorsExternalTokenHttpAuthenticationBasic {
    /**
     * Password for basic HTTP authentication.
     */
    password: string;
    /**
     * Username for basic HTTP authentication.
     */
    username: string;
}

export interface ProjectConnectorsFingerprint {
    /**
     * The Cloudflare integration Endpoint URL.
     */
    cloudflareEndpointUrl: string;
    /**
     * The Cloudflare integration Script URL.
     */
    cloudflareScriptUrl: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Fingerprint public API key.
     */
    publicApiKey: string;
    /**
     * The Fingerprint secret API key.
     */
    secretApiKey: string;
    /**
     * Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
     */
    useCloudflareIntegration: boolean;
}

export interface ProjectConnectorsFingerprintDescope {
    /**
     * The custom domain to fetch
     */
    customDomain: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsFirebaseAdmin {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Firebase service account JSON.
     */
    serviceAccount: string;
}

export interface ProjectConnectorsForter {
    /**
     * The Forter API version.
     */
    apiVersion: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Override the user IP address.
     */
    overrideIpAddress: string;
    /**
     * Override the user email.
     */
    overrideUserEmail: string;
    /**
     * Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
     */
    overrides: boolean;
    /**
     * The Forter secret key.
     */
    secretKey: string;
    /**
     * The Forter site ID.
     */
    siteId: string;
}

export interface ProjectConnectorsGenericEmailGateway {
    /**
     * Authentication Information
     */
    authentication: outputs.ProjectConnectorsGenericEmailGatewayAuthentication;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The headers to send with the request
     */
    headers: {[key: string]: string};
    /**
     * HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
     */
    hmacSecret: string;
    id: string;
    /**
     * Will ignore certificate errors raised by the client
     */
    insecure: boolean;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The URL of the post email request
     */
    postUrl: string;
    /**
     * The sender address
     */
    sender: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsGenericEmailGatewayAuthentication {
    /**
     * API key authentication configuration.
     */
    apiKey: outputs.ProjectConnectorsGenericEmailGatewayAuthenticationApiKey;
    /**
     * Basic authentication credentials (username and password).
     */
    basic: outputs.ProjectConnectorsGenericEmailGatewayAuthenticationBasic;
    /**
     * Bearer token for HTTP authentication.
     */
    bearerToken: string;
}

export interface ProjectConnectorsGenericEmailGatewayAuthenticationApiKey {
    /**
     * The API key.
     */
    key: string;
    /**
     * The API secret.
     */
    token: string;
}

export interface ProjectConnectorsGenericEmailGatewayAuthenticationBasic {
    /**
     * Password for basic HTTP authentication.
     */
    password: string;
    /**
     * Username for basic HTTP authentication.
     */
    username: string;
}

export interface ProjectConnectorsGenericSmsGateway {
    /**
     * Authentication Information
     */
    authentication: outputs.ProjectConnectorsGenericSmsGatewayAuthentication;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The headers to send with the request
     */
    headers: {[key: string]: string};
    /**
     * HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
     */
    hmacSecret: string;
    id: string;
    /**
     * Will ignore certificate errors raised by the client
     */
    insecure: boolean;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The URL of the post message request
     */
    postUrl: string;
    /**
     * The sender number
     */
    sender: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsGenericSmsGatewayAuthentication {
    /**
     * API key authentication configuration.
     */
    apiKey: outputs.ProjectConnectorsGenericSmsGatewayAuthenticationApiKey;
    /**
     * Basic authentication credentials (username and password).
     */
    basic: outputs.ProjectConnectorsGenericSmsGatewayAuthenticationBasic;
    /**
     * Bearer token for HTTP authentication.
     */
    bearerToken: string;
}

export interface ProjectConnectorsGenericSmsGatewayAuthenticationApiKey {
    /**
     * The API key.
     */
    key: string;
    /**
     * The API secret.
     */
    token: string;
}

export interface ProjectConnectorsGenericSmsGatewayAuthenticationBasic {
    /**
     * Password for basic HTTP authentication.
     */
    password: string;
    /**
     * Username for basic HTTP authentication.
     */
    username: string;
}

export interface ProjectConnectorsGoogleCloudLogging {
    /**
     * Whether to enable streaming of audit events.
     */
    auditEnabled: boolean;
    /**
     * Specify which events will be sent to the external audit service (including tenant selection).
     */
    auditFilters: outputs.ProjectConnectorsGoogleCloudLoggingAuditFilter[];
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * A Service Account Key JSON file created from a service account on your Google Cloud project. This file is used to authenticate and authorize the connector to access Google Cloud Logging. The service account this key belongs to must have the appropriate permissions to write logs.
     */
    serviceAccountKey: string;
    /**
     * Whether to send troubleshooting events.
     */
    troubleshootLogEnabled: boolean;
}

export interface ProjectConnectorsGoogleCloudLoggingAuditFilter {
    /**
     * The field name to filter on (either 'actions' or 'tenants').
     */
    key: string;
    /**
     * The filter operation to apply ('includes' or 'excludes').
     */
    operator: string;
    /**
     * The list of values to match against for the filter.
     */
    values: string[];
}

export interface ProjectConnectorsGoogleCloudTranslation {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Google Cloud project ID where the Google Cloud Translation is managed.
     */
    projectId: string;
    /**
     * Service Account JSON associated with the current project.
     */
    serviceAccountJson: string;
}

export interface ProjectConnectorsGoogleMapsPlace {
    /**
     * The address types to return.
     */
    addressTypes: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * The language in which to return results.
     */
    language: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Google Maps Places public API key.
     */
    publicApiKey: string;
    /**
     * The region code, specified as a CLDR two-character region code.
     */
    region: string;
}

export interface ProjectConnectorsHibp {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsHttp {
    /**
     * Authentication Information
     */
    authentication: outputs.ProjectConnectorsHttpAuthentication;
    /**
     * The base URL to fetch
     */
    baseUrl: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The headers to send with the request
     */
    headers: {[key: string]: string};
    /**
     * HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
     */
    hmacSecret: string;
    id: string;
    /**
     * The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
     */
    includeHeadersInContext: boolean;
    /**
     * Will ignore certificate errors raised by the client
     */
    insecure: boolean;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsHttpAuthentication {
    /**
     * API key authentication configuration.
     */
    apiKey: outputs.ProjectConnectorsHttpAuthenticationApiKey;
    /**
     * Basic authentication credentials (username and password).
     */
    basic: outputs.ProjectConnectorsHttpAuthenticationBasic;
    /**
     * Bearer token for HTTP authentication.
     */
    bearerToken: string;
}

export interface ProjectConnectorsHttpAuthenticationApiKey {
    /**
     * The API key.
     */
    key: string;
    /**
     * The API secret.
     */
    token: string;
}

export interface ProjectConnectorsHttpAuthenticationBasic {
    /**
     * Password for basic HTTP authentication.
     */
    password: string;
    /**
     * Username for basic HTTP authentication.
     */
    username: string;
}

export interface ProjectConnectorsHubspot {
    /**
     * The HubSpot private API access token generated for the Descope service.
     */
    accessToken: string;
    /**
     * The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
     */
    baseUrl: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsIncode {
    /**
     * Your InCode API key.
     */
    apiKey: string;
    /**
     * The base URL of the Incode API
     */
    apiUrl: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * Your wanted InCode's flow ID.
     */
    flowId: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsIntercom {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Regional Hosting - US, EU, or AU. default: US
     */
    region: string;
    /**
     * The Intercom access token.
     */
    token: string;
}

export interface ProjectConnectorsLokalise {
    /**
     * Lokalise API token.
     */
    apiToken: string;
    /**
     * (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
     */
    cardId: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Lokalise project ID.
     */
    projectId: string;
    /**
     * Lokalise team ID. If not provided, the oldest available team will be used.
     */
    teamId: string;
    /**
     * The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
     */
    translationProvider: string;
}

export interface ProjectConnectorsMparticle {
    /**
     * The mParticle Server to Server Key generated for the Descope service.
     */
    apiKey: string;
    /**
     * The mParticle Server to Server Secret generated for the Descope service.
     */
    apiSecret: string;
    /**
     * The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
     */
    baseUrl: string;
    /**
     * The default environment of which connector send data to, either production or development. default value: production. This field can be overridden per event (see at flows).
     */
    defaultEnvironment: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsNewrelic {
    /**
     * Ingest License Key of the account you want to report data to.
     */
    apiKey: string;
    /**
     * Whether to enable streaming of audit events.
     */
    auditEnabled: boolean;
    /**
     * Specify which events will be sent to the external audit service (including tenant selection).
     */
    auditFilters: outputs.ProjectConnectorsNewrelicAuditFilter[];
    /**
     * The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
     */
    dataCenter: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * Specify a custom prefix for all log fields. The default prefix is `descope.`.
     */
    logsPrefix: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Enable this option to use a custom prefix for log fields.
     */
    overrideLogsPrefix: boolean;
    /**
     * Whether to send troubleshooting events.
     */
    troubleshootLogEnabled: boolean;
}

export interface ProjectConnectorsNewrelicAuditFilter {
    /**
     * The field name to filter on (either 'actions' or 'tenants').
     */
    key: string;
    /**
     * The filter operation to apply ('includes' or 'excludes').
     */
    operator: string;
    /**
     * The list of values to match against for the filter.
     */
    values: string[];
}

export interface ProjectConnectorsRadar {
    /**
     * The address types to return.
     */
    addressTypes: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * The language in which to return results.
     */
    language: string;
    /**
     * The maximum number of results to return.
     */
    limit: number;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Radar publishable API key.
     */
    publicApiKey: string;
    /**
     * The region code, specified as a two-letter ISO 3166 code.
     */
    region: string;
}

export interface ProjectConnectorsRecaptcha {
    /**
     * When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
     */
    assessmentScore: number;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
     */
    overrideAssessment: boolean;
    /**
     * The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
     */
    secretKey: string;
    /**
     * The site key is used to invoke reCAPTCHA service on your site or mobile application.
     */
    siteKey: string;
}

export interface ProjectConnectorsRecaptchaEnterprise {
    /**
     * API key associated with the current project.
     */
    apiKey: string;
    /**
     * When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
     */
    assessmentScore: number;
    /**
     * Apply a custom url to the reCAPTCHA Enterprise scripts. This is useful when attempting to use reCAPTCHA globally. Defaults to https://www.google.com
     */
    baseUrl: string;
    /**
     * The bot threshold is used to determine whether the request is a bot or a human. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot. If the score is below this threshold, the request is considered a bot.
     */
    botThreshold: number;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
     */
    overrideAssessment: boolean;
    /**
     * The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
     */
    projectId: string;
    /**
     * The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
     */
    siteKey: string;
}

export interface ProjectConnectorsRekognition {
    /**
     * The AWS access key ID
     */
    accessKeyId: string;
    /**
     * The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
     */
    collectionId: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The AWS secret access key
     */
    secretAccessKey: string;
}

export interface ProjectConnectorsSalesforce {
    /**
     * The Salesforce API base URL.
     */
    baseUrl: string;
    /**
     * The consumer key of the connected app.
     */
    clientId: string;
    /**
     * The consumer secret of the connected app.
     */
    clientSecret: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * REST API Version.
     */
    version: string;
}

export interface ProjectConnectorsSalesforceMarketingCloud {
    /**
     * Account identifier, or MID, of the target business unit.
     */
    accountId: string;
    /**
     * Client ID issued when you create the API integration in Installed Packages.
     */
    clientId: string;
    /**
     * Client secret issued when you create the API integration in Installed Packages.
     */
    clientSecret: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Space-separated list of data-access permissions for your connector.
     */
    scope: string;
    /**
     * The Salesforce Marketing Cloud endpoint subdomain.
     */
    subdomain: string;
}

export interface ProjectConnectorsSardine {
    /**
     * The base URL for the Sardine API, e.g.: https://api.sandbox.sardine.ai, https://api.sardine.ai, https://api.eu.sardine.ai.
     */
    baseUrl: string;
    /**
     * The Sardine Client ID.
     */
    clientId: string;
    /**
     * The Sardine Client Secret.
     */
    clientSecret: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsSe {
    /**
     * AWS Access key ID.
     */
    accessKeyId: string;
    /**
     * The authentication type to use.
     */
    authType: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * An optional endpoint URL (hostname only or fully qualified URI).
     */
    endpoint: string;
    /**
     * The external ID to use when assuming the role.
     */
    externalId: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * AWS region to send requests to (e.g. `us-west-2`).
     */
    region: string;
    /**
     * The Amazon Resource Name (ARN) of the role to assume.
     */
    roleArn: string;
    /**
     * AWS Secret Access Key.
     */
    secret: string;
    /**
     * The sender details that should be displayed in the email message.
     */
    sender: outputs.ProjectConnectorsSeSender;
}

export interface ProjectConnectorsSeSender {
    /**
     * The email address that will appear as the sender of the email.
     */
    email: string;
    /**
     * The display name that will appear as the sender of the email.
     */
    name: string;
}

export interface ProjectConnectorsSegment {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The base URL of the Segment API, when using a custom domain in Segment.
     */
    host: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Segment Write Key generated for the Descope service.
     */
    writeKey: string;
}

export interface ProjectConnectorsSendgrid {
    /**
     * SendGrid API authentication configuration.
     */
    authentication: outputs.ProjectConnectorsSendgridAuthentication;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The sender details that should be displayed in the email message.
     */
    sender: outputs.ProjectConnectorsSendgridSender;
}

export interface ProjectConnectorsSendgridAuthentication {
    /**
     * SendGrid API key for authentication.
     */
    apiKey: string;
}

export interface ProjectConnectorsSendgridSender {
    /**
     * The email address that will appear as the sender of the email.
     */
    email: string;
    /**
     * The display name that will appear as the sender of the email.
     */
    name: string;
}

export interface ProjectConnectorsSlack {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The OAuth token for Slack's Bot User, used to authenticate API requests.
     */
    token: string;
}

export interface ProjectConnectorsSmartling {
    /**
     * The account UID for the Smartling account.
     */
    accountUid: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The user identifier for the Smartling account.
     */
    userIdentifier: string;
    /**
     * The user secret for the Smartling account.
     */
    userSecret: string;
}

export interface ProjectConnectorsSmtp {
    /**
     * SMTP server authentication credentials and method.
     */
    authentication: outputs.ProjectConnectorsSmtpAuthentication;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The sender details that should be displayed in the email message.
     */
    sender: outputs.ProjectConnectorsSmtpSender;
    /**
     * SMTP server connection details including hostname and port.
     */
    server: outputs.ProjectConnectorsSmtpServer;
    /**
     * Whether the connector should send all requests from specific static IPs.
     */
    useStaticIps: boolean;
}

export interface ProjectConnectorsSmtpAuthentication {
    /**
     * SMTP authentication method (`plain` or `login`).
     */
    method: string;
    /**
     * Password for SMTP server authentication.
     */
    password: string;
    /**
     * Username for SMTP server authentication.
     */
    username: string;
}

export interface ProjectConnectorsSmtpSender {
    /**
     * The email address that will appear as the sender of the email.
     */
    email: string;
    /**
     * The display name that will appear as the sender of the email.
     */
    name: string;
}

export interface ProjectConnectorsSmtpServer {
    /**
     * The hostname or IP address of the SMTP server.
     */
    host: string;
    /**
     * The port number to connect to on the SMTP server.
     */
    port: number;
}

export interface ProjectConnectorsSn {
    /**
     * AWS Access key ID.
     */
    accessKeyId: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * An optional endpoint URL (hostname only or fully qualified URI).
     */
    endpoint: string;
    /**
     * The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
     */
    entityId: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Use the `originationNumber` attribute instead.
     *
     * @deprecated The organizationNumber attribute has been renamed, set the originationNumber attribute instead. This attribute will be removed in a future version of the provider.
     */
    organizationNumber: string;
    /**
     * An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
     */
    originationNumber: string;
    /**
     * AWS region to send requests to (e.g. `us-west-2`).
     */
    region: string;
    /**
     * AWS Secret Access Key.
     */
    secret: string;
    /**
     * The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
     */
    senderId: string;
    /**
     * The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
     */
    templateId: string;
}

export interface ProjectConnectorsSumologic {
    /**
     * Whether to enable streaming of audit events.
     */
    auditEnabled: boolean;
    /**
     * Specify which events will be sent to the external audit service (including tenant selection).
     */
    auditFilters: outputs.ProjectConnectorsSumologicAuditFilter[];
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The URL associated with an HTTP Hosted collector
     */
    httpSourceUrl: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Whether to send troubleshooting events.
     */
    troubleshootLogEnabled: boolean;
}

export interface ProjectConnectorsSumologicAuditFilter {
    /**
     * The field name to filter on (either 'actions' or 'tenants').
     */
    key: string;
    /**
     * The filter operation to apply ('includes' or 'excludes').
     */
    operator: string;
    /**
     * The list of values to match against for the filter.
     */
    values: string[];
}

export interface ProjectConnectorsSupabase {
    /**
     * The authentication type to use.
     */
    authType: string;
    /**
     * Enable to automatically create users in Supabase when generating tokens. Will only create a new user if one does not already exist. When disabled, only JWT tokens will be generated, WITHOUT user creation.
     */
    createUsers: boolean;
    /**
     * A mapping of Descope user fields or JWT claims to Supabase custom claims
     */
    customClaimsMapping: {[key: string]: string};
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * The duration in minutes for which the token is valid.
     */
    expirationTime: number;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The private key in JWK format used to sign the JWT. You can generate a key using tools like `npx supabase gen signing-key --algorithm ES256`. Make sure to use the ES256 algorithm.
     */
    privateKey: string;
    /**
     * Your Supabase Project's API base URL, e.g.: https://\n\n.supabase.co.
     */
    projectBaseUrl: string;
    /**
     * The service role API key for your Supabase project, required to create users.
     */
    serviceRoleApiKey: string;
    /**
     * The signing secret for your Supabase project.
     */
    signingSecret: string;
}

export interface ProjectConnectorsTelesign {
    /**
     * The unique Telesign API key
     */
    apiKey: string;
    /**
     * The unique Telesign account Customer ID
     */
    customerId: string;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
}

export interface ProjectConnectorsTraceable {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    /**
     * EU(Europe) Region deployment of Traceable platform.
     */
    euRegion: boolean;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The Traceable secret key.
     */
    secretKey: string;
}

export interface ProjectConnectorsTurnstile {
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * The secret key authorizes communication between Descope backend and the Turnstile server to verify the user's response.
     */
    secretKey: string;
    /**
     * The site key is used to invoke Turnstile service on your site or mobile application.
     */
    siteKey: string;
}

export interface ProjectConnectorsTwilioCore {
    /**
     * Twilio Account SID from your Twilio Console.
     */
    accountSid: string;
    /**
     * Twilio authentication credentials (either auth token or API key/secret).
     */
    authentication: outputs.ProjectConnectorsTwilioCoreAuthentication;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Configuration for SMS and voice message senders.
     */
    senders: outputs.ProjectConnectorsTwilioCoreSenders;
}

export interface ProjectConnectorsTwilioCoreAuthentication {
    /**
     * Twilio API Key for authentication (used with API Secret).
     */
    apiKey: string;
    /**
     * Twilio API Secret for authentication (used with API Key).
     */
    apiSecret: string;
    /**
     * Twilio Auth Token for authentication.
     */
    authToken: string;
}

export interface ProjectConnectorsTwilioCoreSenders {
    /**
     * SMS sender configuration using either a phone number or messaging service.
     */
    sms: outputs.ProjectConnectorsTwilioCoreSendersSms;
    /**
     * Voice call sender configuration.
     */
    voice: outputs.ProjectConnectorsTwilioCoreSendersVoice;
}

export interface ProjectConnectorsTwilioCoreSendersSms {
    /**
     * Twilio Messaging Service SID for sending SMS messages.
     */
    messagingServiceSid: string;
    /**
     * Twilio phone number for sending SMS messages.
     */
    phoneNumber: string;
}

export interface ProjectConnectorsTwilioCoreSendersVoice {
    /**
     * Twilio phone number for making voice calls.
     */
    phoneNumber: string;
}

export interface ProjectConnectorsTwilioVerify {
    /**
     * Twilio Account SID from your Twilio Console.
     */
    accountSid: string;
    /**
     * Twilio authentication credentials (either auth token or API key/secret).
     */
    authentication: outputs.ProjectConnectorsTwilioVerifyAuthentication;
    /**
     * A description of what your connector is used for.
     */
    description: string;
    id: string;
    /**
     * A custom name for your connector.
     */
    name: string;
    /**
     * Optional sender identifier for verification messages.
     */
    sender: string;
    /**
     * Twilio Verify Service SID for verification services.
     */
    serviceSid: string;
}

export interface ProjectConnectorsTwilioVerifyAuthentication {
    /**
     * Twilio API Key for authentication (used with API Secret).
     */
    apiKey: string;
    /**
     * Twilio API Secret for authentication (used with API Key).
     */
    apiSecret: string;
    /**
     * Twilio Auth Token for authentication.
     */
    authToken: string;
}

export interface ProjectFlows {
    /**
     * The JSON data defining the authentication flow configuration, including metadata, screens, contents, and references.
     */
    data: string;
}

export interface ProjectInviteSettings {
    /**
     * Whether to include a magic link token in invitation messages.
     */
    addMagiclinkToken: boolean;
    /**
     * Settings related to sending invitation emails.
     */
    emailService: outputs.ProjectInviteSettingsEmailService;
    /**
     * Expire the user account if the invitation is not accepted within the expiration time.
     */
    expireInvitedUsers: boolean;
    /**
     * The expiry time for the invitation, meant to be used together with `expireInvitedUsers` and/or `addMagiclinkToken`. Use values such as "2 weeks", "4 days", etc. The minimum value is "1 hour".
     */
    inviteExpiration: string;
    /**
     * Custom URL to include in the message sent to invited users.
     */
    inviteUrl: string;
    /**
     * Whether users must be invited before they can sign up to the project.
     */
    requireInvitation: boolean;
    /**
     * Whether to send invitation emails to users.
     */
    sendEmail: boolean;
    /**
     * Whether to send invitation SMS messages to users.
     */
    sendText: boolean;
}

export interface ProjectInviteSettingsEmailService {
    /**
     * The name of the email connector to use for sending emails.
     */
    connector: string;
    /**
     * A list of email templates for different authentication flows.
     */
    templates: outputs.ProjectInviteSettingsEmailServiceTemplate[];
}

export interface ProjectInviteSettingsEmailServiceTemplate {
    /**
     * Whether this email template is currently active and in use.
     */
    active: boolean;
    /**
     * HTML content of the email message body, required if `usePlainTextBody` isn't set.
     */
    htmlBody: string;
    id: string;
    /**
     * Unique name for this email template.
     */
    name: string;
    /**
     * Plain text version of the email message body, required if `usePlainTextBody` is set to `true`.
     */
    plainTextBody: string;
    /**
     * Subject line of the email message.
     */
    subject: string;
    /**
     * Whether to use the plain text body instead of HTML for the email.
     */
    usePlainTextBody: boolean;
}

export interface ProjectJwtTemplates {
    /**
     * A list of `Access Key` type JWT Templates.
     */
    accessKeyTemplates: outputs.ProjectJwtTemplatesAccessKeyTemplate[];
    /**
     * A list of `User` type JWT Templates.
     */
    userTemplates: outputs.ProjectJwtTemplatesUserTemplate[];
}

export interface ProjectJwtTemplatesAccessKeyTemplate {
    /**
     * The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
     */
    authSchema: string;
    /**
     * When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
     */
    autoTenantClaim: boolean;
    /**
     * Whether to use OIDC conformance for the JWT issuer field.
     */
    conformanceIssuer: boolean;
    /**
     * Description of the JWT Template.
     */
    description: string;
    /**
     * Policy for empty claims - `none`, `nil` or `delete`.
     */
    emptyClaimPolicy: string;
    /**
     * Whether to enforce that the JWT issuer matches the project configuration.
     */
    enforceIssuer: boolean;
    id: string;
    /**
     * Name of the JWT Template.
     */
    name: string;
    /**
     * The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
     */
    template: string;
}

export interface ProjectJwtTemplatesUserTemplate {
    /**
     * The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
     */
    authSchema: string;
    /**
     * When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
     */
    autoTenantClaim: boolean;
    /**
     * Whether to use OIDC conformance for the JWT issuer field.
     */
    conformanceIssuer: boolean;
    /**
     * Description of the JWT Template.
     */
    description: string;
    /**
     * Policy for empty claims - `none`, `nil` or `delete`.
     */
    emptyClaimPolicy: string;
    /**
     * Whether to enforce that the JWT issuer matches the project configuration.
     */
    enforceIssuer: boolean;
    id: string;
    /**
     * Name of the JWT Template.
     */
    name: string;
    /**
     * The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
     */
    template: string;
}

export interface ProjectList {
    /**
     * The JSON data for the list. The format depends on the `type`: - For `"texts"` and `"ips"` types: Must be a JSON array of strings (e.g., `["item1", "item2"]`) - For `"ips"` type: Each string must be a valid IP address or CIDR range - For `"json"` type: Must be a JSON object (e.g., `{"key": "value"}`)
     */
    data: string;
    /**
     * An optional description for the list. Defaults to an empty string if not provided.
     */
    description: string;
    id: string;
    /**
     * The name of the list. Maximum length is 100 characters.
     */
    name: string;
    /**
     * The type of list. Must be one of: - `"texts"` - A list of text strings - `"ips"` - A list of IP addresses or CIDR ranges - `"json"` - A JSON object
     */
    type: string;
}

export interface ProjectProjectSettings {
    /**
     * Name of the access key JWT Template.
     */
    accessKeyJwtTemplate: string;
    /**
     * The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
     */
    accessKeySessionTokenExpiration: string;
    /**
     * The URL which your application resides on.
     */
    appUrl: string;
    /**
     * The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
     */
    approvedDomains: string[];
    /**
     * A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
     */
    customDomain: string;
    /**
     * Define whether a user created with no federated apps, will have access to all apps, or will not have access to any app.
     */
    defaultNoSsoApps: boolean;
    /**
     * Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
     */
    enableInactivity: boolean;
    /**
     * The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
     */
    inactivityTime: string;
    /**
     * The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
     */
    refreshTokenCookieDomain: string;
    /**
     * Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
     */
    refreshTokenCookiePolicy: string;
    /**
     * The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
     */
    refreshTokenExpiration: string;
    /**
     * Configure how refresh tokens are managed by the Descope SDKs. Must be either `responseBody` or `cookies`. The default value is `responseBody`.
     */
    refreshTokenResponseMethod: string;
    /**
     * Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
     */
    refreshTokenRotation: boolean;
    /**
     * Configure seamless migration of existing user sessions from another vendor to Descope.
     */
    sessionMigration: outputs.ProjectProjectSettingsSessionMigration;
    /**
     * The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
     */
    sessionTokenCookieDomain: string;
    /**
     * Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
     */
    sessionTokenCookiePolicy: string;
    /**
     * The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
     */
    sessionTokenExpiration: string;
    /**
     * Configure how sessions tokens are managed by the Descope SDKs. Must be either `responseBody` or `cookies`. The default value is `responseBody`.
     */
    sessionTokenResponseMethod: string;
    /**
     * The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
     */
    stepUpTokenExpiration: string;
    /**
     * Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
     */
    testUsersLoginidRegexp: string;
    /**
     * A 6 digit static OTP code for use with test users.
     */
    testUsersStaticOtp: string;
    /**
     * The pattern of the verifiers that will be used for testing.
     */
    testUsersVerifierRegexp: string;
    /**
     * The expiry time for the trusted device token. The minimum value is "3 minutes".
     */
    trustedDeviceTokenExpiration: string;
    /**
     * Name of the user JWT Template.
     */
    userJwtTemplate: string;
}

export interface ProjectProjectSettingsSessionMigration {
    /**
     * The audience value if needed by the vendor.
     */
    audience: string;
    /**
     * The unique client ID for the vendor.
     */
    clientId: string;
    /**
     * The domain value if needed by the vendor.
     */
    domain: string;
    /**
     * An issuer URL if needed by the vendor.
     */
    issuer: string;
    /**
     * A set of attributes from the vendor's user that should be used to match with the Descope user's login ID.
     */
    loginidMatchedAttributes: string[];
    /**
     * The name of the vendor the sessions are migrated from, in all lowercase.
     */
    vendor: string;
}

export interface ProjectStyles {
    /**
     * The JSON data defining the visual styling and theme configuration used for authentication, widgets, etc.
     */
    data: string;
}

export interface ProjectWidgets {
    /**
     * The JSON data defining the widget. This will usually be exported as a `.json` file from the Descope console, and set in the `.tf` file using the `data = file("...")` syntax.
     */
    data: string;
}

